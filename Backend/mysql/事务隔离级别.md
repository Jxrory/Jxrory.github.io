# mysql 事务

## 事务特征

事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）

### 原子性

> 事务是数据库的逻辑工作单位, 事务中包含的各操作要么都做, 要么都不做

### 一致性

> 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时, 就说数据库处于一致性状态。如果数据库系统 运行中发生故障, 有些事务尚未完成就被迫中断, 这些未完成事务对数据库所做的修改有一部分已写入物理数据库, 这时数据库就处于一种不正确的状态, 或者说是 不一致的状态。

### 隔离性

> 一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的, 并发执行的各个事务之间不能互相干扰。

### 持续性

> 也称永久性, 指一个事务一旦提交, 它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。

## Mysql 事务的隔离级别

`脏读`、`不可重复读`、`幻读`概念说明:

`脏读`: 指当一个事务正在访问数据, 并且对数据进行了修改, 而这种数据还没有提交到数据库中, 此时, 另外一个事务也访问这个数据, 然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。

`不可重复读`: 指在一个事务内, 多次读同一数据。在这个事务还没有执行结束, 另外一个事务也访问该同一数据, 那么在第一个事务中的两次读取数据之间, 由于第二个事务的修改第一个事务两次读到的数据可能是不一样的, 这样就发生了在一个事物内两次连续读到的数据是不一样的, 这种情况被称为是不可重复读。

`幻读`: 一个事务先后读取一个范围的记录, 但两次读取的纪录数不同, 我们称之为幻读（两次执行同一条 select 语句会出现不同的结果, 第二次读会增加一数据行, 并没有说这两次执行是在同一个事务中）

### 读未提交 （Read uncommitted）

> A事务可以读取B事务未提交的数据

特例1:

```text
A: 启动事务, 查询数据c

B: 启动事务, 更新数据c, 但不提交

A: 再次读取数据c, 发现数据已经被修改了, 这就是所谓的“脏读”

B: 回滚事务

A: 再次读数据, 发现数据变回初始状态
```

### 读提交（Read Committed）

> 只能读到已经提交了的内容, 最常用的一种隔离级别, 也是SQL Server和Oracle的默认隔离级别

特例2:

```text
A: 启动事务, 查询数据c

B: 启动事务, 更新数据c, 但不提交

A: 再次读数据c, 发现数据c未被修改 **Q: 为何读不到已经更新的数据? 是通过“快照读（Snapshot Read）”实现的**

B: 提交事务

A: 再次读取数据c, 发现数据c已发生变化, 说明B提交的修改被事务中的A读到了, 这就是所谓的“不可重复读”
```

### 可重复读(Repeated Read)

> 专门针对“不可重复读”这种情况而制定的隔离级别, 可以有效的避免“不可重复读”, 是MySql的默认隔离级别。

特例3:

```text
A: 启动事务, 查询数据集{c,d} # 此时d数据还不存在

B: 启动事务, 更新数据c, 但不提交

A: 再次读取数据c, 发现数据c未被修改

B: 提交事务

A: 再次读取数据c, 发现数据c依然未发生变化, 这说明这次可以重复读了

C: 插入一条新的数据d, 并提交

A: 再次读取数据, 发现数据变化为{c, d}, 这就是所谓的“幻读”

A: 提交本次事务

```

### 序列化 Serializable

> 事务“串行化顺序执行”, 但是执行效率奇差, 性能开销也最大.

**参考**
[https://www.cnblogs.com/myseries/p/10748912.html](https://www.cnblogs.com/myseries/p/10748912.html)
[https://www.cnblogs.com/jian-gao/p/10795407.html](https://www.cnblogs.com/jian-gao/p/10795407.html)
