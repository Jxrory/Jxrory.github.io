# 地理反编码设计方案

## 需求

业务主要针对的尼日利亚, 使用的货币是`NGN(奈拉)`, 需要对用户的登录区域做限制.

## 方案

0. 准备数据: 尼日利亚的主要城市的经纬度数据;
1. 数据处理: 使用数据生成一颗 KD-Tree 2;
2. 匹配距离用户最近的城市并计算出距离;
3. 查看用户的距离是否超过阈值, 超过就是不在尼日利亚, 没有超过就认为是在尼日利亚.

### 匹配最近城市原理

这里使用的算法是 `k-D Tree` 做的一个近邻匹配.

由于地图可以延展成 2 维平面, $k=2$ 时, 可以将 `k-D Tree` 想象成如下图形:

![k-D Tree 2维的原理图](./_images/kdt1.jpg ':size=50%')

其中, `A`, `B`, `C`, `D`... 就是城市/地方的代表, 选取 `D` 节点为第一个划分的节点(根节点), 再选取 `C`, `E` 节点作为第二划分节点, 就能将地图划分完.

![k-D Tree 二叉树形式](./_images/kdt2.jpg ':size=50%')

其中树上每个结点上的坐标是选择的分割点的坐标，非叶子结点旁的 x 或 y 是选择的切割维度。

**示例**:

假设用户的坐标点 `user_geo`: (2, 8)

![k-D Tree 2维的示例](./_images/kdt1-user-geo.png ':size=50%')

### 坐标之间距离的计算公式

#### 基本思路

用户距离最近的城市一般不会超过 200 千米, 由于范围小，可以认为经线和纬线是垂直的，如图所示，要求 A（116.8，39,78）和 B（116.9，39.68）两点的距离，我们可以先求出南北方向距离 AM，然后求出东西方向距离 BM，最后求矩形对角线距离，即 $\sqrt{AM^2 + BM^2}$ 。

![geo-距离计算示例](./_images/geo-距离计算示例.png ':size=50%')

$$
AM(南北方向) = R * d_x * \pi / 180.0
$$

$$
 BM(东西方向) = R * d_y * \cos{(b * \pi / 180.0)}
$$

> $d_x$: 维度差
>
> $d_y$: 进度差
>
> $b$: 平均纬度
>
> $R$: 地球半径 `6367000`

#### Java 代码实现

```java
/**
    * 计算两点直接的距离
    *
    * @return 距离
    */
public static double distanceSimplify(GeoName geoS, GeoName geoT) {
    // 经度差值
    double dx = geoS.longitude - geoT.longitude;
    // 纬度差值
    double dy = geoS.latitude - geoT.latitude;
    // 平均纬度
    double b = (geoS.latitude + geoT.latitude) / 2.0;
    // 东西距离
    double lx = toRadians(dx) * R * Math.cos(toRadians(b));
    // 南北距离
    double ly = R * toRadians(dy);
    // 用平面的矩形对角距离公式计算总距离
    return Math.sqrt(lx * lx + ly * ly);
}

private static double toRadians(double v) {
    return v * Math.PI / 180.0;
}
```

### 线上数据验证

验证的总条数: `8713` 条

| 阈值(m) | 通过率(%) |
| ------- | --------- |
| 1000    | 60.82     |
| 2000    | 89.88     |
| 3000    | 95.56     |
| 4000    | 98.03     |
| 5000    | 98.39     |
| `6000`  | 98.51     |
| 7000    | 98.51     |
| 8000    | 98.52     |
| 10000   | 98.52     |
| 20000   | 98.53     |
| 30000   | 98.54     |

选取阈值 `6000` , 未通过用户所处位置的可视化.

## 总结

与 `引射线法` 相比 `KD-Tree 方案` 优点更加明显:

> 缺点:
>
> - 存在一定的误判率, 使用线上的数据进行测试, 存在 **1.5%** 的误判(可以添加补点消除这个问题).
>
> 优点:
>
> - 快速高效;
> - 可以动态添加坐标点, 可以对盲区进行覆盖.

## 参考

- [算法详解—— 5 种方法怎么判断一个点是否在多边形区域内](https://www.cnblogs.com/xzit-xiaxu/p/15676165.html)
- [判断一个点是否在多边形区域内部 / 判断一个给定位置是否位于某个城市内部](https://www.cnblogs.com/yinyoupoet/p/13287362.html)
- [地理空间距离计算优化](https://tech.meituan.com/2014/09/05/lucene-distance.html)
